# Focus-Bot
<ins>Keep an eye out with A.I.!</ins>

**Team members:**   
Gabriela Onelli - [g-onelli](https://github.com/g-onelli)   
Erick Lim - [redroach51](https://github.com/redroach51)   
Steven Santiago - [Stev0439](https://github.com/Stev0439)

[DESIGN.md](https://github.com/Stev0439/Focus-Bot/blob/main/DESIGN.md)

[PROCESS.md](https://github.com/Stev0439/Focus-Bot/blob/main/PROCESS.md)

**HW 5 Reflection:**

<ins>What was most helpful about thinking about design methods of your project?</ins><br>
The most helpful thing about thinking on our design methods was simply putting things together. It was as simple as considering what things people wanted from our project, and figuring out how people would navigate to those things. <br>
<ins>What was most difficult? What would you do differently?</ins><br>
Trying to place whether a deviation from a use case is a subflow that continues on or an alternative flow that cancels operations was problematic. I'm not sure what else could be done differently about the process, as it appears to just be brainstroming potential error events that could occur during use. Perhaps maybe have someone in brainstorming who's whole job is to try and suggest break scenarios in the use case? <br>
<ins>What design methods might you want to try again in the future on another project?</ins><br>
I liked modeling the system in UMLet. I am very interested in doing that again for another project.<br>

<ins>What was most helpful about implementing, testing, and integration in your bot project?</ins><br>
I'm aware this should be more about using Github to work as a team, but honestly? The most helpful thing was more information regarding our language. Google's Manifest V3 is a pain to work with, and almost all of it's documentation seemed incomplete or incompatible with Manifest V2's APIs. I did not like that.<br>
<ins>What was most difficult? What would you do differently?</ins><br>
Working in Google's Manifest V3 was a terrible idea. It was buggy, sparse in reliable documentation or experienced users, and deviated significantly from Manifest V2. Worst of all, it used Javascript. If I could do everything differently, I would use Manifest V2 to keep our "Chrome Extension" novelty, but to lessen the pain from using a new system.<br>
<ins>What implementation, testing, and integration methods might you want to try again in the future on another project?</ins><br>
Having each user work on a seperate branch that merges into the main as opposed to directly working on the main is a process I'm very happy with, and will continue to use in the future.

<ins>What was most helpful about implementing kanban and code review in your project?</ins><br>
Not entirely sure. Kanban boards and code reviews seemed and felt like a big "proceedure for proceedure's sake" scenario. Made me think "That sounds just like assigning use cases but with extra steps".<br>
<ins>What was most difficult? What would you do differently?</ins><br>
Keeping track of everyone's Kanban boards is very difficult when nobody's really reading or updating them. I'm honestly not even sure if I would implement it as a host if I were to do a project with a team this small.<br>
<ins>What software processes or practices might you want to try again in the future on another project?</ins><br>
With a bigger team (and way more tasks to bear) I think Kanban might be worth trying again. As of right now, the scope of our project and the size of our team meant it was very ineffective, but I'd love to see how it scales up.<br>

<ins>Considering all the design methods, implementation practices, and software processes you've encountered---compare and contrast how the benefits of the different practices and how they might be useful together.</ins><br>
All these practices and processes and methods have one thing in common: They're great for assisting in a team's project development. When team cohesion is low and coordination is lacking, these tools help give direction to individual members and break down large abstract goals into individualized tasks. However, if the team already is working well together without these tools for any reason (project is small, teammates understand each other well, team size is small), these tools end up just stretching out the development process. They should only be used as necessary, not as a catch-all for any software project ever made.
